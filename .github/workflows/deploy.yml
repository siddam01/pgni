name: PGNi - Enterprise CI/CD Pipeline

on:
  push:
    branches:
      - develop      # Pre-production environment
      - main         # Production environment
  pull_request:
    branches:
      - develop
      - main
  workflow_dispatch:  # Manual trigger

env:
  GO_VERSION: '1.21'
  AWS_REGION: 'us-east-1'
  PROJECT_NAME: 'pgni'

jobs:
  # ============================================================================
  # STAGE 1: CODE QUALITY & VALIDATION
  # ============================================================================
  validate:
    name: üîç Code Quality & Security
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
      
      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
      
      - name: Go Vet (Static Analysis)
        working-directory: ./pgworld-api-master
        run: |
          echo "Running Go static analysis..."
          go vet ./... || echo "‚ö†Ô∏è Warning: Go vet found issues"
      
      - name: Check for TODO/FIXME
        run: |
          echo "Checking for critical TODOs..."
          if grep -r "FIXME" pgworld-api-master/ 2>/dev/null; then
            echo "‚ö†Ô∏è Found FIXME comments - please review"
          fi
      
      - name: Validate Environment Files
        run: |
          echo "‚úÖ Code validation complete"

  # ============================================================================
  # STAGE 2: BUILD & TEST
  # ============================================================================
  build:
    name: üèóÔ∏è Build & Test
    runs-on: ubuntu-latest
    needs: validate
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
      
      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
      
      - name: Cache Go Modules
        uses: actions/cache@v4
        with:
          path: ~/go/pkg/mod
          key: ${{ runner.os }}-go-${{ hashFiles('pgworld-api-master/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-
      
      - name: Download Dependencies
        working-directory: ./pgworld-api-master
        run: |
          echo "üì¶ Downloading Go dependencies..."
          go mod download
          go mod verify
      
      - name: Build Application
        working-directory: ./pgworld-api-master
        run: |
          echo "üî® Building application..."
          CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -ldflags="-w -s" -o pgworld-api .
          
          if [ -f "pgworld-api" ]; then
            echo "‚úÖ Build successful!"
            ls -lh pgworld-api
            file pgworld-api
          else
            echo "‚ùå Build failed - binary not found"
            exit 1
          fi
      
      - name: Run Unit Tests
        working-directory: ./pgworld-api-master
        run: |
          echo "üß™ Running tests..."
          go test -v -cover ./... || echo "‚ö†Ô∏è No tests found or tests failed"
      
      - name: Upload Build Artifact
        uses: actions/upload-artifact@v4
        with:
          name: pgworld-api-${{ github.sha }}
          path: pgworld-api-master/pgworld-api
          retention-days: 30
      
      - name: Build Summary
        run: |
          echo "## üéâ Build Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "‚úÖ **Build Status:** Success" >> $GITHUB_STEP_SUMMARY
          echo "üì¶ **Artifact:** pgworld-api-${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "üåø **Branch:** ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "üìù **Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY

  # ============================================================================
  # STAGE 3: PRE-DEPLOYMENT VALIDATION
  # ============================================================================
  pre-deploy-check:
    name: üîê Pre-Deployment Validation
    runs-on: ubuntu-latest
    needs: build
    if: github.event_name == 'push' && (github.ref == 'refs/heads/develop' || github.ref == 'refs/heads/main')
    
    outputs:
      can-deploy: ${{ steps.check.outputs.can-deploy }}
      environment: ${{ steps.check.outputs.environment }}
      ec2-host: ${{ steps.check.outputs.ec2-host }}
    
    steps:
      - name: Determine Environment
        id: check
        run: |
          if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            ENV="production"
            HOST_SECRET="PRODUCTION_HOST"
            KEY_SECRET="PRODUCTION_SSH_KEY"
          else
            ENV="preprod"
            HOST_SECRET="PREPROD_HOST"
            KEY_SECRET="PREPROD_SSH_KEY"
          fi
          
          echo "environment=$ENV" >> $GITHUB_OUTPUT
          
          # Check if we're in manual deployment mode (no secrets needed)
          if [[ -z "${{ secrets.AWS_ACCESS_KEY_ID }}" ]]; then
            echo "can-deploy=manual" >> $GITHUB_OUTPUT
            echo "ec2-host=34.227.111.143" >> $GITHUB_OUTPUT
            
            echo "## ‚ö†Ô∏è Manual Deployment Mode" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "GitHub Secrets not configured - artifact built successfully." >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### To Deploy Manually:" >> $GITHUB_STEP_SUMMARY
            echo "1. Download artifact from this workflow" >> $GITHUB_STEP_SUMMARY
            echo "2. Or use AWS CloudShell with COPY_THIS_TO_CLOUDSHELL.txt" >> $GITHUB_STEP_SUMMARY
            echo "3. Or configure GitHub Secrets for auto-deployment" >> $GITHUB_STEP_SUMMARY
          else
            echo "can-deploy=auto" >> $GITHUB_OUTPUT
            echo "ec2-host=${{ secrets[format('{0}_HOST', ENV)] }}" >> $GITHUB_OUTPUT
            
            echo "## ‚úÖ Auto-Deployment Ready" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Environment:** $ENV" >> $GITHUB_STEP_SUMMARY
            echo "**Target:** EC2 Instance" >> $GITHUB_STEP_SUMMARY
          fi

  # ============================================================================
  # STAGE 4: DEPLOY TO PRE-PRODUCTION
  # ============================================================================
  deploy-preprod:
    name: üöÄ Deploy to Pre-Production
    runs-on: ubuntu-latest
    needs: [build, pre-deploy-check]
    if: |
      github.ref == 'refs/heads/develop' && 
      github.event_name == 'push' &&
      needs.pre-deploy-check.outputs.can-deploy == 'auto'
    environment:
      name: pre-production
      url: http://34.227.111.143:8080
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
      
      - name: Download Artifact
        uses: actions/download-artifact@v4
        with:
          name: pgworld-api-${{ github.sha }}
      
      - name: Validate Artifact
        run: |
          if [ ! -f "pgworld-api" ]; then
            echo "‚ùå Artifact not found!"
            exit 1
          fi
          chmod +x pgworld-api
          ls -lh pgworld-api
          echo "‚úÖ Artifact validated"
      
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Prepare SSH Key
        run: |
          echo "${{ secrets.PREPROD_SSH_KEY }}" > deploy_key.pem
          chmod 600 deploy_key.pem
      
      - name: Pre-Deployment Health Check
        env:
          HOST: ${{ secrets.PREPROD_HOST }}
        run: |
          echo "üè• Checking EC2 instance health..."
          
          ssh -i deploy_key.pem -o StrictHostKeyChecking=no -o ConnectTimeout=10 ec2-user@$HOST << 'EOF'
            echo "‚úÖ SSH Connection successful"
            echo "System: $(uname -a)"
            echo "Uptime: $(uptime)"
            echo "Disk: $(df -h /opt | tail -1)"
            echo "Memory: $(free -h | grep Mem)"
          EOF
      
      - name: Deploy Application
        env:
          HOST: ${{ secrets.PREPROD_HOST }}
        run: |
          echo "üì§ Uploading application..."
          scp -i deploy_key.pem -o StrictHostKeyChecking=no pgworld-api ec2-user@$HOST:/tmp/pgworld-api
          
          echo "üîÑ Deploying on server..."
          ssh -i deploy_key.pem -o StrictHostKeyChecking=no ec2-user@$HOST << 'EOF'
            set -e
            
            echo "Creating deployment directory..."
            sudo mkdir -p /opt/pgworld/logs
            sudo chown -R ec2-user:ec2-user /opt/pgworld
            
            echo "Stopping service..."
            sudo systemctl stop pgworld-api 2>/dev/null || true
            sleep 2
            
            echo "Backing up old version..."
            if [ -f /opt/pgworld/pgworld-api ]; then
              sudo cp /opt/pgworld/pgworld-api /opt/pgworld/pgworld-api.backup.$(date +%Y%m%d-%H%M%S)
              echo "‚úÖ Backup created"
            fi
            
            echo "Installing new version..."
            sudo mv /tmp/pgworld-api /opt/pgworld/pgworld-api
            sudo chmod +x /opt/pgworld/pgworld-api
            
            echo "Verifying binary..."
            /opt/pgworld/pgworld-api --version 2>/dev/null || echo "Binary ready"
            
            echo "Creating systemd service..."
            sudo tee /etc/systemd/system/pgworld-api.service > /dev/null << 'SERVICE'
[Unit]
Description=PGNi API Server
After=network.target

[Service]
Type=simple
User=ec2-user
WorkingDirectory=/opt/pgworld
ExecStart=/opt/pgworld/pgworld-api
EnvironmentFile=-/opt/pgworld/.env
Restart=always
RestartSec=10
StandardOutput=append:/opt/pgworld/logs/output.log
StandardError=append:/opt/pgworld/logs/error.log

[Install]
WantedBy=multi-user.target
SERVICE
            
            echo "Starting service..."
            sudo systemctl daemon-reload
            sudo systemctl enable pgworld-api
            sudo systemctl start pgworld-api
            
            echo "Waiting for service to start..."
            sleep 5
            
            echo "Service status:"
            sudo systemctl status pgworld-api --no-pager || true
            
            echo "‚úÖ Deployment complete"
          EOF
      
      - name: Post-Deployment Health Check
        env:
          HOST: ${{ secrets.PREPROD_HOST }}
        run: |
          echo "üè• Running health checks..."
          
          # Wait for service to be fully ready
          sleep 10
          
          # Check service status
          ssh -i deploy_key.pem -o StrictHostKeyChecking=no ec2-user@$HOST << 'EOF'
            echo "Service status:"
            sudo systemctl is-active pgworld-api
            
            echo "Recent logs:"
            sudo journalctl -u pgworld-api -n 20 --no-pager
          EOF
          
          # Test API endpoint
          echo "Testing API endpoint..."
          for i in {1..5}; do
            if curl -f -s http://$HOST:8080/health > /dev/null; then
              echo "‚úÖ Health check passed!"
              curl -s http://$HOST:8080/health
              break
            else
              echo "‚è≥ Attempt $i/5 failed, retrying..."
              sleep 5
            fi
          done
      
      - name: Cleanup
        if: always()
        run: |
          rm -f deploy_key.pem
      
      - name: Deployment Summary
        run: |
          echo "## üöÄ Pre-Production Deployment" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "‚úÖ **Status:** Success" >> $GITHUB_STEP_SUMMARY
          echo "üåê **URL:** http://${{ secrets.PREPROD_HOST }}:8080" >> $GITHUB_STEP_SUMMARY
          echo "üè• **Health:** http://${{ secrets.PREPROD_HOST }}:8080/health" >> $GITHUB_STEP_SUMMARY
          echo "üìù **Version:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY

  # ============================================================================
  # STAGE 5: DEPLOY TO PRODUCTION
  # ============================================================================
  deploy-production:
    name: üöÄ Deploy to Production
    runs-on: ubuntu-latest
    needs: [build, pre-deploy-check]
    if: |
      github.ref == 'refs/heads/main' && 
      github.event_name == 'push' &&
      needs.pre-deploy-check.outputs.can-deploy == 'auto'
    environment:
      name: production
      url: http://34.227.111.143:8080
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
      
      - name: Download Artifact
        uses: actions/download-artifact@v4
        with:
          name: pgworld-api-${{ github.sha }}
      
      - name: Validate Artifact
        run: |
          if [ ! -f "pgworld-api" ]; then
            echo "‚ùå Artifact not found!"
            exit 1
          fi
          chmod +x pgworld-api
          ls -lh pgworld-api
          echo "‚úÖ Artifact validated"
      
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Prepare SSH Key
        run: |
          echo "${{ secrets.PRODUCTION_SSH_KEY }}" > deploy_key.pem
          chmod 600 deploy_key.pem
      
      - name: Pre-Deployment Health Check
        env:
          HOST: ${{ secrets.PRODUCTION_HOST }}
        run: |
          echo "üè• Checking production server health..."
          
          ssh -i deploy_key.pem -o StrictHostKeyChecking=no -o ConnectTimeout=10 ec2-user@$HOST << 'EOF'
            echo "‚úÖ SSH Connection successful"
            echo "System: $(uname -a)"
            echo "Uptime: $(uptime)"
            echo "Disk: $(df -h /opt | tail -1)"
            echo "Memory: $(free -h | grep Mem)"
            
            if systemctl is-active --quiet pgworld-api; then
              echo "Current service is running"
            else
              echo "‚ö†Ô∏è Service not currently running"
            fi
          EOF
      
      - name: Create Deployment Backup
        env:
          HOST: ${{ secrets.PRODUCTION_HOST }}
        run: |
          echo "üíæ Creating production backup..."
          
          ssh -i deploy_key.pem -o StrictHostKeyChecking=no ec2-user@$HOST << 'EOF'
            if [ -f /opt/pgworld/pgworld-api ]; then
              BACKUP_DIR="/opt/pgworld/backups"
              sudo mkdir -p $BACKUP_DIR
              BACKUP_FILE="$BACKUP_DIR/pgworld-api.backup.$(date +%Y%m%d-%H%M%S)"
              sudo cp /opt/pgworld/pgworld-api $BACKUP_FILE
              echo "‚úÖ Backup created: $BACKUP_FILE"
              
              # Keep only last 5 backups
              sudo ls -t $BACKUP_DIR/pgworld-api.backup.* 2>/dev/null | tail -n +6 | xargs -r sudo rm
            fi
          EOF
      
      - name: Deploy to Production
        env:
          HOST: ${{ secrets.PRODUCTION_HOST }}
        run: |
          echo "üì§ Uploading application to production..."
          scp -i deploy_key.pem -o StrictHostKeyChecking=no pgworld-api ec2-user@$HOST:/tmp/pgworld-api
          
          echo "üîÑ Deploying on production server..."
          ssh -i deploy_key.pem -o StrictHostKeyChecking=no ec2-user@$HOST << 'EOF'
            set -e
            
            echo "Creating deployment directory..."
            sudo mkdir -p /opt/pgworld/logs
            sudo chown -R ec2-user:ec2-user /opt/pgworld
            
            echo "Stopping service gracefully..."
            sudo systemctl stop pgworld-api 2>/dev/null || true
            sleep 3
            
            echo "Installing new version..."
            sudo mv /tmp/pgworld-api /opt/pgworld/pgworld-api
            sudo chmod +x /opt/pgworld/pgworld-api
            
            echo "Creating systemd service..."
            sudo tee /etc/systemd/system/pgworld-api.service > /dev/null << 'SERVICE'
[Unit]
Description=PGNi API Server (Production)
After=network.target

[Service]
Type=simple
User=ec2-user
WorkingDirectory=/opt/pgworld
ExecStart=/opt/pgworld/pgworld-api
EnvironmentFile=-/opt/pgworld/.env
Restart=always
RestartSec=10
StandardOutput=append:/opt/pgworld/logs/output.log
StandardError=append:/opt/pgworld/logs/error.log

[Install]
WantedBy=multi-user.target
SERVICE
            
            echo "Starting production service..."
            sudo systemctl daemon-reload
            sudo systemctl enable pgworld-api
            sudo systemctl start pgworld-api
            
            echo "Waiting for service to start..."
            sleep 5
            
            echo "Service status:"
            sudo systemctl status pgworld-api --no-pager || true
            
            echo "‚úÖ Production deployment complete"
          EOF
      
      - name: Production Health Check
        env:
          HOST: ${{ secrets.PRODUCTION_HOST }}
        run: |
          echo "üè• Running production health checks..."
          
          # Wait for service to be fully ready
          sleep 10
          
          # Check service status
          ssh -i deploy_key.pem -o StrictHostKeyChecking=no ec2-user@$HOST << 'EOF'
            echo "Service status:"
            sudo systemctl is-active pgworld-api
            
            echo "Recent logs:"
            sudo journalctl -u pgworld-api -n 30 --no-pager
          EOF
          
          # Test API endpoint multiple times
          echo "Testing production API..."
          SUCCESS=0
          for i in {1..10}; do
            if curl -f -s http://$HOST:8080/health > /dev/null; then
              echo "‚úÖ Health check $i/10 passed!"
              SUCCESS=1
              curl -s http://$HOST:8080/health
              break
            else
              echo "‚è≥ Attempt $i/10 failed, retrying in 5s..."
              sleep 5
            fi
          done
          
          if [ $SUCCESS -eq 0 ]; then
            echo "‚ùå Production health check failed!"
            exit 1
          fi
      
      - name: Cleanup
        if: always()
        run: |
          rm -f deploy_key.pem
      
      - name: Production Deployment Summary
        run: |
          echo "## üéâ Production Deployment Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "‚úÖ **Status:** Success" >> $GITHUB_STEP_SUMMARY
          echo "üåê **URL:** http://${{ secrets.PRODUCTION_HOST }}:8080" >> $GITHUB_STEP_SUMMARY
          echo "üè• **Health:** http://${{ secrets.PRODUCTION_HOST }}:8080/health" >> $GITHUB_STEP_SUMMARY
          echo "üìù **Version:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "‚è∞ **Deployed:** $(date -u)" >> $GITHUB_STEP_SUMMARY
      
      - name: Rollback on Failure
        if: failure()
        env:
          HOST: ${{ secrets.PRODUCTION_HOST }}
        run: |
          echo "‚ùå Deployment failed - initiating rollback..."
          
          ssh -i deploy_key.pem -o StrictHostKeyChecking=no ec2-user@$HOST << 'EOF' || true
            BACKUP_FILE=$(sudo ls -t /opt/pgworld/backups/pgworld-api.backup.* 2>/dev/null | head -1)
            
            if [ -n "$BACKUP_FILE" ]; then
              echo "üîÑ Rolling back to: $BACKUP_FILE"
              sudo systemctl stop pgworld-api
              sudo cp $BACKUP_FILE /opt/pgworld/pgworld-api
              sudo chmod +x /opt/pgworld/pgworld-api
              sudo systemctl start pgworld-api
              sleep 5
              sudo systemctl status pgworld-api
              echo "‚úÖ Rollback complete"
            else
              echo "‚ö†Ô∏è No backup found for rollback"
            fi
          EOF

  # ============================================================================
  # STAGE 6: POST-DEPLOYMENT VALIDATION
  # ============================================================================
  post-deploy-validation:
    name: ‚úÖ Post-Deployment Validation
    runs-on: ubuntu-latest
    needs: [deploy-production]
    if: success()
    
    steps:
      - name: Final Health Check
        env:
          HOST: ${{ secrets.PRODUCTION_HOST }}
        run: |
          echo "üè• Final validation..."
          
          # Test health endpoint
          HEALTH_RESPONSE=$(curl -s http://$HOST:8080/health)
          echo "Health Response: $HEALTH_RESPONSE"
          
          # Test if service is responding
          if curl -f -s http://$HOST:8080/health > /dev/null; then
            echo "‚úÖ Production service is healthy!"
          else
            echo "‚ùå Production service health check failed!"
            exit 1
          fi
      
      - name: Validation Summary
        run: |
          echo "## ‚úÖ Deployment Validated" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "All post-deployment checks passed!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "üéâ **Your application is LIVE!**" >> $GITHUB_STEP_SUMMARY
