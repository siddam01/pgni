# PGNi Infrastructure Configuration
# This YAML file defines all infrastructure requirements, dependencies, and validation rules

project:
  name: PGNi
  description: PG Management System - Cloud Infrastructure
  version: 1.0.0
  owner: PGNi-Team
  repository: https://github.com/siddam01/pgni

environments:
  preprod:
    name: Pre-Production
    purpose: Testing and staging
    aws_region: us-east-1
    aws_account_id: "698302425856"
    cost_target: "$0-5/month (Free Tier)"
    
  production:
    name: Production
    purpose: Live environment for end users
    aws_region: us-east-1
    aws_account_id: "698302425856"
    cost_target: "$50-100/month"

infrastructure_components:
  
  database:
    service: AWS RDS
    engine: MySQL
    engine_version: 8.0.35
    purpose: Store PG data, tenant information, payments
    
    requirements:
      preprod:
        instance_class: db.t3.micro
        storage_gb: 20
        max_storage_gb: 100
        backup_retention_days: 7
        multi_az: false
        publicly_accessible: true
        free_tier_eligible: true
        
      production:
        instance_class: db.t3.small
        storage_gb: 50
        max_storage_gb: 250
        backup_retention_days: 30
        multi_az: true
        publicly_accessible: false
        free_tier_eligible: false
    
    configuration:
      port: 3306
      database_name: pgworld
      username: pgniuser
      character_set: utf8mb4
      collation: utf8mb4_unicode_ci
      max_connections: 100
      
    security:
      encryption_at_rest: true
      encryption_in_transit: true
      ssl_required: false
      access_from:
        - EC2 security group only
      
    monitoring:
      cloudwatch_logs:
        - error
        - general
        - slowquery
      enhanced_monitoring: true  # Production only
      
    dependencies:
      - VPC
      - Subnet Group
      - Security Group
      - KMS Key (optional)
  
  storage:
    service: AWS S3
    purpose: File uploads (PG photos, tenant documents)
    
    requirements:
      bucket_name_pattern: "{project}-{environment}-{account_id}-uploads"
      versioning: true
      encryption: AES256  # Or KMS
      
    configuration:
      cors:
        allowed_methods:
          - GET
          - PUT
          - POST
          - DELETE
          - HEAD
        allowed_origins:
          - "*"  # Update with app domains in production
        allowed_headers:
          - "*"
        expose_headers:
          - ETag
        max_age_seconds: 3000
        
      lifecycle_policies:
        - name: delete-old-versions
          noncurrent_version_expiration_days: 90
        - name: transition-to-ia
          transition_to_ia_days: 30
          transition_to_glacier_days: 90
          enabled_in: production
          
    security:
      block_public_access: true
      access_control: IAM
      access_from:
        - EC2 instance role
        
    dependencies:
      - IAM Role
      - Bucket Policy
  
  compute:
    service: AWS EC2
    os: Amazon Linux 2023
    purpose: Run PGNi API server
    
    requirements:
      preprod:
        instance_type: t3.micro
        vcpu: 2
        memory_gb: 1
        storage_gb: 20
        free_tier_eligible: true
        static_ip: false
        
      production:
        instance_type: t3.small
        vcpu: 2
        memory_gb: 2
        storage_gb: 30
        free_tier_eligible: false
        static_ip: true  # Elastic IP
        
    software_stack:
      runtime:
        - name: Go
          version: 1.21.0
          installation: /usr/local/go
        - name: Git
          version: latest
        - name: MySQL Client
          version: latest
          
      services:
        - name: pgworld-api
          type: systemd
          port: 8080
          restart_policy: always
          log_destination: journald
          
    security:
      ssh_key: auto-generated
      instance_metadata: IMDSv2
      iam_role: yes
      security_group: yes
      
    monitoring:
      detailed_monitoring: true  # Production only
      cloudwatch_agent: true
      
    dependencies:
      - VPC
      - Subnet
      - Security Group
      - IAM Instance Profile
      - SSH Key Pair
      - Elastic IP (production)
  
  networking:
    vpc:
      type: default
      cidr: default
      
    security_groups:
      rds:
        name: "{project}-{environment}-rds-sg"
        description: Security group for RDS database
        inbound_rules:
          - protocol: tcp
            port: 3306
            source: ec2-security-group
            description: MySQL from EC2
        outbound_rules:
          - protocol: all
            port: all
            destination: 0.0.0.0/0
            
      ec2:
        name: "{project}-{environment}-api-sg"
        description: Security group for API server
        inbound_rules:
          - protocol: tcp
            port: 22
            source: configurable  # Restrict to your IP
            description: SSH access
          - protocol: tcp
            port: 8080
            source: 0.0.0.0/0
            description: API access
          - protocol: tcp
            port: 443
            source: 0.0.0.0/0
            description: HTTPS access (future)
        outbound_rules:
          - protocol: all
            port: all
            destination: 0.0.0.0/0
  
  iam:
    roles:
      ec2_instance_role:
        name: "{project}-{environment}-ec2-role"
        service: ec2.amazonaws.com
        policies:
          - S3 Access (read/write to uploads bucket)
          - SSM Parameter Store (read parameters)
          - CloudWatch Logs (write logs)
          - KMS (decrypt if enabled)
        managed_policies:
          - AmazonSSMManagedInstanceCore
          
      rds_monitoring_role:
        name: "{project}-{environment}-rds-monitoring-role"
        service: monitoring.rds.amazonaws.com
        managed_policies:
          - AmazonRDSEnhancedMonitoringRole
        enabled_in: production
  
  secrets_management:
    service: AWS Systems Manager Parameter Store
    path_pattern: "/{project}/{environment}/"
    
    parameters:
      - name: db/endpoint
        type: String
        description: RDS database endpoint
        
      - name: db/username
        type: String
        description: RDS database username
        
      - name: db/password
        type: SecureString
        description: RDS database password
        encryption: AWS managed or KMS
        
      - name: db/name
        type: String
        description: RDS database name
        
      - name: s3/bucket
        type: String
        description: S3 bucket name
        
      - name: ec2/public_ip
        type: String
        description: EC2 instance public IP
        
      - name: ec2/private_key
        type: SecureString
        description: SSH private key
        encryption: AWS managed or KMS
  
  encryption:
    kms:
      key_id: arn:aws:kms:us-east-1:698302425856:key/mrk-1b96d9eeccf649e695ed6ac2b13cb619
      alias: app-pg-key
      enabled_by_default: false
      
      usage:
        - RDS encryption
        - S3 bucket encryption
        - EC2 volume encryption
        - SSM parameter encryption

dependencies:
  required_tools:
    - name: Terraform
      version: ">= 1.0"
      purpose: Infrastructure as Code
      installation: https://www.terraform.io/downloads
      
    - name: AWS CLI
      version: ">= 2.0"
      purpose: AWS API interaction
      installation: https://aws.amazon.com/cli/
      
    - name: Git
      version: ">= 2.0"
      purpose: Version control
      installation: https://git-scm.com/downloads
      
  aws_permissions:
    required_iam_policies:
      - AmazonEC2FullAccess
      - AmazonRDSFullAccess
      - AmazonS3FullAccess
      - IAMFullAccess
      - AmazonSSMFullAccess
      - AmazonVPCFullAccess
      
  runtime_dependencies:
    api_server:
      - Go 1.21+
      - MySQL Client
      - Git
      
    database:
      - MySQL 8.0
      
validation_rules:
  pre_deployment:
    - check: aws_credentials_configured
      command: aws sts get-caller-identity
      expected: Account ID 698302425856
      
    - check: terraform_installed
      command: terraform version
      expected: version >= 1.0
      
    - check: correct_region
      validation: AWS region is us-east-1
      
    - check: sufficient_quotas
      validations:
        - EC2 instances: >= 1
        - RDS instances: >= 1
        - S3 buckets: >= 1
        - Elastic IPs: >= 1 (production)
        
  post_deployment:
    - check: rds_available
      validation: RDS status is 'available'
      timeout_minutes: 20
      
    - check: rds_connectivity
      command: mysql -h {rds_endpoint} -u {username} -p
      expected: Connection successful
      
    - check: s3_accessible
      command: aws s3 ls s3://{bucket_name}
      expected: No error
      
    - check: s3_cors_configured
      validation: CORS rules are present
      
    - check: ec2_running
      validation: EC2 status is 'running'
      
    - check: ec2_ssh_accessible
      command: ssh -i key.pem ec2-user@{public_ip}
      expected: Connection successful
      
    - check: security_groups_configured
      validations:
        - RDS allows MySQL from EC2
        - EC2 allows SSH from allowed IPs
        - EC2 allows HTTP on 8080
        
    - check: iam_roles_attached
      validations:
        - EC2 has instance profile
        - EC2 can access S3
        - EC2 can read SSM parameters
        
    - check: ssm_parameters_created
      validations:
        - /{project}/{env}/db/endpoint exists
        - /{project}/{env}/db/password exists
        - /{project}/{env}/s3/bucket exists
        
    - check: api_service_configured
      command: ssh ec2 "systemctl status pgworld-api"
      expected: Unit file exists
      
  runtime_validation:
    - check: api_health
      endpoint: http://{ec2_ip}:8080/health
      expected_response: '{"status":"ok"}'
      
    - check: database_connection
      validation: API can connect to database
      
    - check: s3_upload
      validation: API can upload to S3
      
    - check: s3_download
      validation: API can download from S3

cost_optimization:
  free_tier_eligible:
    - db.t3.micro (750 hours/month)
    - t3.micro (750 hours/month)
    - S3 (5 GB storage, 20K GET, 2K PUT)
    - Data transfer (100 GB/month)
    
  recommendations:
    - Use t3.micro/db.t3.micro for preprod
    - Enable S3 lifecycle policies
    - Stop non-production instances when not in use
    - Use RDS automated backups instead of manual snapshots
    - Monitor CloudWatch for unused resources
    
  cost_alerts:
    preprod:
      threshold: $10/month
      action: Email notification
      
    production:
      threshold: $100/month
      action: Email notification

deployment_workflow:
  steps:
    1_prepare:
      - Install Terraform
      - Install AWS CLI
      - Configure AWS credentials
      - Clone repository
      
    2_configure:
      - cd terraform/
      - copy terraform.tfvars.example terraform.tfvars
      - Edit terraform.tfvars
      
    3_validate:
      - terraform init
      - terraform validate
      - Run pre-deployment validations
      
    4_plan:
      - terraform plan -var="environment=preprod"
      - Review planned changes
      
    5_deploy:
      - terraform apply -var="environment=preprod"
      - Wait 15-20 minutes
      
    6_save_outputs:
      - terraform output -raw ssh_private_key > key.pem
      - terraform output -raw environment_file > .env
      - terraform output > deployment-info.txt
      
    7_verify:
      - Run post-deployment validations
      - SSH to EC2
      - Connect to database
      - Test S3 access
      
    8_deploy_application:
      - SSH to EC2
      - Clone application repository
      - Build API
      - Configure environment
      - Start service
      
    9_test:
      - Run runtime validations
      - Test API endpoints
      - Test file uploads
      
    10_monitor:
      - Check CloudWatch logs
      - Monitor costs
      - Set up alerts

rollback_procedure:
  steps:
    1_identify_issue:
      - Check Terraform state
      - Review error logs
      
    2_rollback_application:
      - SSH to EC2
      - Stop service
      - Restore previous version
      - Start service
      
    3_rollback_infrastructure:
      - terraform destroy (if needed)
      - Or restore from previous state
      
    4_verify:
      - Test previous version
      - Confirm functionality

maintenance:
  regular_tasks:
    daily:
      - Check CloudWatch logs
      - Monitor API health
      
    weekly:
      - Review cost reports
      - Check backup status
      - Update security patches
      
    monthly:
      - Review and optimize resources
      - Update AMIs
      - Rotate credentials (quarterly)
      
  updates:
    terraform:
      - Review Terraform updates
      - Test in preprod first
      - Update production after validation
      
    application:
      - Use CI/CD pipeline
      - Deploy to preprod first
      - Monitor for issues
      - Deploy to production

disaster_recovery:
  rds:
    automated_backups: yes
    backup_window: "03:00-04:00 UTC"
    retention_period: 7 days (preprod), 30 days (production)
    restore_procedure: AWS Console or terraform
    
  s3:
    versioning: enabled
    cross_region_replication: optional
    restore_procedure: S3 versioning
    
  ec2:
    ami_snapshots: manual or automated
    restore_procedure: Launch from AMI

compliance:
  data_protection:
    encryption_at_rest: yes
    encryption_in_transit: yes
    
  access_control:
    principle_of_least_privilege: yes
    iam_roles: yes
    mfa: recommended
    
  audit:
    cloudwatch_logs: enabled
    cloudtrail: recommended
    
  backup:
    automated: yes
    tested_restores: recommended quarterly

---
# End of Infrastructure Configuration
# Version: 1.0.0
# Last Updated: 2025-01-08

